import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import RegularPolygon, Rectangle, Circle
from matplotlib.widgets import Button, RadioButtons
from matplotlib.animation import FuncAnimation
from itertools import product
from datetime import datetime
from BoardGen import *
from scipy.signal import convolve2d
import csv
from keras import models
import time

class MineSweeper:
    # Saved Values for customization
    covered_color = '#DDDDDD'
    uncovered_color = '#AAAAAA'
    edge_color = '#888888'
    count_colors = ['none', 'blue', 'green', 'red', 'darkblue',
                    'darkred', 'darkgreen', 'black', 'black']
    flag_vertices = np.array([[0.25, 0.2], [0.25, 0.8],
                              [0.75, 0.65], [0.25, 0.5]])

    def __init__(self, rows=9, col=9, per=0.125):
        # Initialize MineSweeper instance with given parameters

        # Flag indicating if it's the first click
        self.first_click = True

        # Flag indicating if the board is being reset
        self.resetting_board = False

        # Minesweeper board generated by the 'Game' class
        self._game = Game(rows, col, per)
        self.tiles = self._game.get_board()

        # Width and height of the board
        self.width = rows
        self.height = col

        # Probability of a tile containing a bomb
        self.chance = per

        # Create the figure and axes
        self.fig, self.ax = plt.subplots(figsize=((self.width + 2) / 3., (self.height + 2) / 3))
        self.ax.set_aspect('equal')
        self.ax.set_frame_on(False)
        self.ax.set_xlim(-0.05, self.width + 0.05)
        self.ax.set_ylim(-0.05, self.height + 0.05)

        # Create bomb count text element
        self.bomb_count_text = self.ax.text(self.width / 4, self.height + 0.3,
                                            f"Flags left: {np.sum(self.tiles == 9)}",
                                            color='red', ha='center', va='center')

        # Create timer text element
        self.start_time = 0
        self.timer_text = self.ax.text(3 * self.width / 4, self.height + 0.3, "Time: 0",
                                       color='blue', ha='center', va='center', visible=True)

        # Create reset button
        reset_button_ax = plt.axes([0.45, 0.95, 0.1, 0.05])
        self.reset_button = Button(reset_button_ax, 'Reset')
        self.reset_button.on_clicked(self._reset_board)
        radio_labels = ['off','Adam', 'RMS', 'SGD','Conv1D: Adam','Conv2D: Adam']
        self._ai_on = False
        radio_axes = plt.axes([0.05, 0.45, 0.1, 0.2], facecolor='lightgoldenrodyellow')
        self.radio_buttons = RadioButtons(radio_axes, radio_labels)
        self.radio_buttons.on_clicked(self._radio_button_selected)
        # Create the grid of squares
        self.squares = np.array([[RegularPolygon((i + 0.5, j + 0.5),
                                                 numVertices=4,
                                                 radius=0.5 * np.sqrt(2),
                                                 orientation=np.pi / 4,
                                                 ec=self.edge_color,
                                                 fc=self.covered_color)
                                  for j in range(self.height)]
                                 for i in range(self.width)])
        [self.ax.add_patch(sq) for sq in self.squares.flat]

        # Internal state variables
        self.clicked = np.zeros((self.width, self.height), dtype=bool)
        self.flags = np.zeros((self.width, self.height), dtype=object)
        self.game_over = False

        # Connect button press event to the _button_press method
        self.fig.canvas.mpl_connect('button_press_event', self._button_press)

        self._model = None
        #self._model = models.load_model("output/minesweeper_AI_Conv1D_binary.h5")

        # Create an automatic move button
        auto_move_button_ax = plt.axes([0.25, 0.95, 0.1, 0.05])
        self.auto_move_button = Button(auto_move_button_ax, 'Auto Move')
        self.auto_move_button.on_clicked(self._auto_move)

        # Initialize an empty list to store game states for replay
        self.replay = []

        # Add a replay button
        replay_button_ax = plt.axes([0.65, 0.95, 0.1, 0.05])
        self.replay_button = Button(replay_button_ax, 'Replay')
        #self.replay_button.on_clicked(self._replay_game)

        self.truestate = np.zeros((self.width, self.height), dtype=int)

        self.best_move = None
        self.best_move_rating = None

        self.no_guess()


    def _replay_game(self, event):
        # Method to replay the game
        replay_viewer = ReplayViewer(self.replay)
        # Add buttons for navigating through states
        prev_button_ax = plt.axes([0.1, 0.05, 0.1, 0.05])
        prev_button = Button(prev_button_ax, 'Previous')
        prev_button.on_clicked(replay_viewer.show_previous_state)

        next_button_ax = plt.axes([0.8, 0.05, 0.1, 0.05])
        next_button = Button(next_button_ax, 'Next')
        next_button.on_clicked(replay_viewer.show_next_state)

        plt.show()


    def _disconnect_events(self):
        # Disconnect all existing events
        for event_type, event_dict in list(self.fig.canvas.callbacks.callbacks.items()):
            for cid, func in list(event_dict.items()):
                self.fig.canvas.mpl_disconnect(cid)

    def _radio_button_selected(self,label):
        print(f'Radio button selected: {label}')
        if label == "off":
            self._ai_on = False
            self._printState()
        elif label == "Adam":
            self._ai_on = True
            self._model = models.load_model("output/minesweeper_AI_Dense_binary_Adam_Cheap.h5")
            self._printState()
        elif label == "RMS":
            self._ai_on = True
            self._model = models.load_model("output/minesweeper_AI_Dense_binary_RMS_Cheap.h5")
            self._printState()
        elif label == "SGD":
            self._ai_on = True
            self._model = models.load_model("output/minesweeper_AI_Dense_binary_SGD_Cheap.h5")
            self._printState()
        elif label == "Conv1D: Adam":
            self._ai_on = True
            self._model = models.load_model("output/minesweeper_AI_Conv1D_binary_Adam.h5")
            self._printState()
        elif label == "Conv2D: Adam":
            self._ai_on = True
            self._model = models.load_model("output/minesweeper_AI_Conv2D_binary_Adam.h5")
            self._printState()

    def _reset_board(self, event):
        # Method to reset the Minesweeper board

        # Check if the reset is already in progress
        self.first_click = True
        if self.resetting_board:
            return

        # Set the flag to indicate that the reset is in progress
        self.resetting_board = True

        # Add code to reset the game state, flags, and update the UI accordingly
        self.game_over = False
        self.clicked = np.zeros((self.width, self.height), dtype=bool)
        self.flags = np.zeros((self.width, self.height), dtype=object)
        self._game = Game(self.width, self.height, self.chance)
        self.tiles = self._game.get_board()

        self.animation = None  # Set animation to None to break out of the generator loop

        # Clear existing patches and texts
        for patch in self.ax.patches:
            patch.remove()
        for text in self.ax.texts:
            text.remove()

        # Recreate the grid of squares using the updated self.tiles
        for i in range(self.width):
            for j in range(self.height):
                square = RegularPolygon((i + 0.5, j + 0.5),
                                        numVertices=4,
                                        radius=0.5 * np.sqrt(2),
                                        orientation=np.pi / 4,
                                        ec=self.edge_color,
                                        fc=self.covered_color)
                self.squares[i, j] = square
                self.ax.add_patch(square)

        # Reset the bomb count and timer UI
        self.bomb_count_text = self.ax.text(self.width / 4, self.height + 0.3,
                                            f"Flags left: {np.sum(self.tiles == 9)}",
                                            color='red', ha='center', va='center')
        self.start_time = datetime.now()
        self.timer_text = self.ax.text(3 * self.width / 4, self.height + 0.3, "Time: 0",
                                       color='blue', ha='center', va='center', visible=True)

        self._update_bomb_count()
        self.timer_text.set_text("Time: 0")
        self.reset_button.label.set_text("Reset")

        # Reset the flag after the reset is complete
        self.resetting_board = False

        # Redraw the updated UI
        self.fig.canvas.draw_idle()



        self.no_guess()

    def _update_timer_text(self, frame):
        # Method to update the timer text during animation
        if self.animation is not None:
            elapsed_time = datetime.now() - self.start_time
            self.timer_text.set_text("Time: " + str(elapsed_time.seconds))
            self.fig.canvas.draw_idle()

    def _update_bomb_count(self):
        # Method to update the bomb count text
        flagged_count = np.sum(self.flags.astype(bool))
        bombs_left = np.sum(self.tiles == 9) - flagged_count
        self.bomb_count_text.set_text(f"Flags left: {bombs_left}")
        self.fig.canvas.draw_idle()  # Redraw only the bomb count text

    def _draw_mine(self, i, j):
        # Method to draw a mine on the board
        self.ax.add_patch(plt.Circle((i + 0.5, j + 0.5), radius=0.25,
                                     ec='black', fc='black'))

    def _draw_red_X(self, i, j,opacity=1):
        # Method to draw a red 'X' on the board
        self.ax.text(i + 0.5, j + 0.5, 'X', color='red', fontsize=20,
                     ha='center', va='center',alpha=opacity)
    def _draw_green_X(self, i, j):
        # Method to draw a red 'X' on the board
        self.ax.text(i + 0.5, j + 0.5, 'X', color='green', fontsize=20,
                     ha='center', va='center')
    def _draw_grey_X(self, i, j):
        # Method to draw a red 'X' on the board
        self.ax.text(i + 0.5, j + 0.5, 'X', color='gray', fontsize=20,
                     ha='center', va='center')

    def _toggle_mine_flag(self, i, j):
        # Method to toggle a flag on a mine

        # Check if the square is already clicked
        if self.clicked[i, j]:
            pass
        # Check if a flag is already present
        elif self.flags[i, j]:
            # Remove the existing flag
            patch_to_remove = self.flags[i, j]
            patch_to_remove.remove()  # Explicitly remove the patch
            self.flags[i, j] = None
        else:
            # Add a new flag
            new_flag = plt.Polygon(self.flag_vertices + [i, j], fc='red', ec='black', lw=2)
            self.ax.add_patch(new_flag)
            self.flags[i, j] = new_flag

        # Update the bomb count
        self._update_bomb_count()

    def _reveal_unmarked_mines(self):
        # Method to reveal unmarked mines on the board

        # Remove existing mine patches
        for patch in self.ax.patches:
            if isinstance(patch, plt.Circle):
                patch.remove()

        # Add patches for the revealed mines
        for (i, j) in zip(*np.where((self.tiles == 9) & ~self.flags.astype(bool))):
            self._draw_mine(i, j)

    def _cross_out_wrong_flags(self):
        # Method to cross out wrongly placed flags on the board

        print("Crossing out wrong flags.")
        for (i, j) in zip(*np.where((self.tiles != 9) & self.flags.astype(bool))):
            self._draw_red_X(i, j)

    def frame_generator(self):
        # Generator function for animation frames
        frame = 0
        while True:
            yield frame
            frame += 1

    def no_guess(self):

        i,j = self._game.get_start()
        self._draw_green_X(i,j)
        # found = False
        #
        # for i in range(len(self.tiles)):
        #     for j in range(len(self.tiles[i])):
        #         if self.tiles[i,j] == 0:
        #             self._draw_green_X(i, j)
        #             found = True
        #         if found:
        #             # pass
        #             break
        #     if found:
        #         #pass
        #         break

    def find_patterns(self, matrix,false_matrix, output_file):
        # with open(output_file, 'a', newline='') as csvfile:
        #     csv_writer = csv.writer(csvfile)
        #
        #     for i in range(1, matrix.shape[0] - 1):
        #         for j in range(1, matrix.shape[1] - 1):
        #             submatrix = matrix[i - 1:i + 2, j - 1:j + 2]
        #
        #             if submatrix[1, 1] == -1 and np.any((submatrix != -1) & (submatrix != 100) & (submatrix != 11)):
        #                 # Flatten the submatrix and concatenate with the result
        #                 flattened_submatrix = submatrix.flatten()
        #                 result = 1 if self.tiles[i - 1, j - 1] == 9 else 0
        #
        #                 # Write to CSV file
        #                 csv_writer.writerow([result] + list(flattened_submatrix))

        # for i in range(1, matrix.shape[0] - 1):
        #     for j in range(1, matrix.shape[1] - 1):
        #         submatrix = matrix[i - 1:i + 2, j - 1:j + 2]
        #
        #         if submatrix[1, 1] == -2 and np.any((submatrix != -1) & (submatrix != 0) & (submatrix != -2)):
        #             # Flatten the submatrix and concatenate with the result
        #             flattened_submatrix = submatrix.flatten()
        #             flattened_submatrix = flattened_submatrix.reshape(1, 9, 1)
        #
        #
        #             predictions = self._model.predict(flattened_submatrix)
        #             if predictions > 0.75:
        #                 self._draw_red_X(i - 2, j - 2)
        #
        #             elif predictions < 0.25:
        #                 self._draw_green_X(i - 2, j - 2)
        #
        #             else:
        #                 self._draw_grey_X(i-2,j-2)

        # with open(output_file, 'a', newline='') as csvfile:
        #     csv_writer = csv.writer(csvfile)
        #
        #     for i in range(2, matrix.shape[0] - 2):
        #         for j in range(2, matrix.shape[1] - 2):
        #             submatrix = matrix[i - 2:i + 3, j - 2:j + 3]
        #             false_submatrix = false_matrix[i - 2:i + 3, j - 2: j + 3]
        #             sub_submatrix = matrix[i - 1:i + 2, j - 1:j + 2]
        #
        #             #if submatrix[2, 2] == -2 and np.any((sub_submatrix != -1) & (sub_submatrix != 0) & (sub_submatrix != -2)):
        #             if submatrix[2, 2] == -1 and np.any((sub_submatrix != -1) & (sub_submatrix != 0)):
        #                 # Flatten the submatrix and concatenate with the result
        #                 flattened_submatrix = false_submatrix.flatten()
        #                 result = 1 if self.tiles[i - 2, j - 2] == 9 else 0
        #
        #                 # Write to CSV file
        #                 csv_writer.writerow([result] + list(flattened_submatrix))
        for text in self.ax.texts:
            if text._text == 'X':
                text.remove()


        if self._ai_on:
            for i in range(2, matrix.shape[0] - 2):
                for j in range(2, matrix.shape[1] - 2):
                    submatrix = matrix[i - 2:i + 3, j - 2:j + 3]
                    false_submatrix = false_matrix[i - 2:i + 3, j - 2:j + 3]
                    sub_submatrix = matrix[i - 1:i + 2, j - 1:j + 2]
                    # if submatrix[2, 2] == -2 and np.any((sub_submatrix != -1) & (sub_submatrix != 0) & (sub_submatrix != -2)):
                    if submatrix[2, 2] == -1 and np.any((sub_submatrix != -1) & (sub_submatrix != 0)):
                        # Flatten the submatrix and concatenate with the result
                        flattened_submatrix = false_submatrix.flatten()
                        flattened_submatrix = flattened_submatrix.reshape(1, 25, 1)

                        predictions = self._model.predict(flattened_submatrix)
                        # if predictions > 0.90:
                        #     self._draw_red_X(i - 2, j - 2)
                        #
                        # elif predictions < 0.1:
                        #     self._draw_green_X(i - 2, j - 2)
                        #
                        # else:
                        #     self._draw_grey_X(i-2,j-2)
                        if self.best_move == None and self.best_move_rating == None:
                            self.best_move = i - 2, j - 2
                            self.best_move_rating = 1 - predictions[0][0]
                        elif 1 - predictions[0][0] > self.best_move_rating:
                            self.best_move = i - 2, j - 2
                            #self.best_move_rating = 1 - predictions[0][0]
                        self._draw_red_X(i - 2, j - 2, predictions[0][0])

    def _auto_move(self, event):
        # Perform the click on the best move
        if self._ai_on:
            if self.best_move:
                i, j = self.best_move
                if self.first_click:
                    i, j = self._game.get_start()
                self._click_square(i, j, True)
                self._printState()
        else:
            print("No AI Chosen")


    def _click_square(self, i, j,bot=False):
        # Method to handle left-click on a square

        # Check if it's the first click
        if self.first_click:
            self.first_click = False
            self.start_time = datetime.now()
            self.animation = FuncAnimation(self.fig, self._update_timer_text, interval=1000)

        # Check if the square is flagged or already clicked
        if self.flags[i, j] or self.clicked[i, j]:
            return

        self.clicked[i, j] = True

        # Check if the square contains a mine
        if self.tiles[i][j] == 9:
            print("Game over! Mine clicked.")
            self.game_over = True
            self._reveal_unmarked_mines()
            self._draw_red_X(i, j)
            self._cross_out_wrong_flags()
            self.animation = None  # Set animation to None to break out of the generator loop
        else:
            # Update the appearance of the square
            self.squares[i, j].set_facecolor(self.uncovered_color)

            # If the square is empty, recursively click its neighbors
            if self.tiles[i][j] == 0:
                for ii in range(max(0, i - 1), min(self.width, i + 2)):
                    for jj in range(max(0, j - 1), min(self.height, j + 2)):
                        self._click_square(ii, jj)
            else:
                # Display the count of neighboring mines
                self.ax.text(i + 0.5, j + 0.5, str(self.tiles[i][j]),
                             color=self.count_colors[self.tiles[i][j]],
                             ha='center', va='center', fontsize=18,
                             fontweight='bold')

            # Check if all non-bomb tiles have been clicked
            non_bomb_tiles = np.where(self.tiles != 9)
            if np.all(self.clicked[non_bomb_tiles]):
                print("Congratulations! You won!")
                self.game_over = True
                self.reset_button.label.set_text("Victory Lap?")
                self.animation = None  # Set animation to None to break out of the generator loop

        # Update the bomb count
        self._update_bomb_count()

        # Redraw the updated UI
        self.fig.canvas.draw_idle()

    def _button_press(self, event):
        # Method to handle button press events

        # Check if the game is over or the event coordinates are None
        if self.game_over or (event.xdata is None) or (event.ydata is None):
            return

        i, j = map(int, (event.xdata, event.ydata))

        # Check if the coordinates are within the board boundaries
        if (i < 0 or j < 0 or i >= self.width or j >= self.height):
            return

        if event.inaxes == self.replay_button.ax:
            return
        if event.inaxes == self.auto_move_button.ax:
            return
        # Check if the button press is on the radio buttons
        if event.inaxes == self.radio_buttons.ax:
            return

        # Check if the button press is on the reset button
        if event.inaxes == self.reset_button.ax:
            return

        # Left mouse button: reveal square. Right mouse button: toggle flag
        if event.button == 1:
            if (self.clicked[i, j]):
                # If the square is already clicked, reveal its neighbors
                flag_count = self.flags[max(0, i - 1):i + 2,
                             max(0, j - 1):j + 2].astype(bool).sum()
                if self.tiles[i][j] == flag_count:
                    for ii, jj in product(range(max(0, i - 1),
                                                min(self.width, i + 2)),
                                          range(max(0, j - 1),
                                                min(self.height, j + 2))):
                        self._click_square(ii, jj)
            else:
                # If the square is not clicked, handle left-click
                self._click_square(i, j)
        elif (event.button == 3):
            # Right mouse button: toggle flag
            self._toggle_mine_flag(i, j)

        # Redraw the updated UI
        self.fig.canvas.draw()

        self._printState()

    def _printState(self):
        ## -1 == flag
        ## -2 == unknown




        self._state = np.empty((len(self.tiles), len(self.tiles[0])), dtype=int)
        self._false_state = np.empty((len(self.tiles), len(self.tiles[0])), dtype=int)

        for i in range(len(self.tiles)):
            for j in range(len(self.tiles[i])):
                if self.clicked[i, j]:
                    self._state[i, j] = self.tiles[i, j]
                    self.truestate[i,j] = self.tiles[i,j]
                    self._false_state[i, j] = self.tiles[i, j]
                elif self.flags[i,j]:
                    self._state[i,j] = 0
                    self.truestate[i,j] = -1
                    self._false_state[i, j] = 0
                else:
                    self._state[i, j] = -1
                    self.truestate[i,j] = -2
                    self._false_state[i, j] = 0


        #self._state = np.pad(self._state, pad_width=1, constant_values=100)
        self._state = np.pad(self._state, pad_width=2, constant_values=0)
        self.replay.append(self.truestate)
        self._false_state = np.pad(self._false_state, pad_width=2, constant_values=0)

        self.find_patterns(self._state,self._false_state,'input/testing_newgen.csv')


def main():
    # Initialize and show the MineSweeper game
    m = MineSweeper(9, 9, 0.125)
    plt.show()

if __name__ == '__main__':
    main()