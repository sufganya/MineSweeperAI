import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import RegularPolygon, Rectangle, Circle
from matplotlib.widgets import Button, RadioButtons
from matplotlib.animation import FuncAnimation
from itertools import product
from datetime import datetime
from BoardGen import *
from scipy.signal import convolve2d
import csv
from keras import models
import time
from Themes import Theme

# Define some themes
themes = {
    'Classic': Theme('#DDDDDD', '#AAAAAA', '#888888', 'red', 'black',
                     ['none', 'blue', 'green', 'red', 'darkblue', 'darkred', 'darkgreen', 'black', 'black']),
    'Dark Mode': Theme('#333333', '#555555', '#777777', 'orange', '#FF5555',
                       ['none', '#1E90FF', '#32CD32', '#FF4500', '#00BFFF', '#DC143C', '#8A2BE2', '#FFFFFF', '#FFFFFF']),
    'Colorful': Theme('#bfe17d', '#e5c29f', '#87af3a', 'red', '#FF00FF',
                      ['none', 'blue', 'green', 'red', 'darkblue', 'darkred', 'darkgreen', 'black', 'black'])
}


class MineSweeper:
    # Saved Values for customization
    covered_color = '#DDDDDD'
    uncovered_color = '#AAAAAA'
    edge_color = '#888888'
    count_colors = ['none', 'blue', 'green', 'red', 'darkblue',
                    'darkred', 'darkgreen', 'black', 'black']
    flag_vertices = np.array([[0.25, 0.2], [0.25, 0.8],
                              [0.75, 0.65], [0.25, 0.5]])

    def __init__(self, difficulty='Beginner'):
        self.difficulty = difficulty
        self._set_difficulty_parameters()  # Set initial parameters based on difficulty

        # Initialize MineSweeper instance with given parameters

        # Flag indicating if it's the first click
        self.first_click = True

        # Flag indicating if the board is being reset
        self.resetting_board = False

        # Minesweeper board generated by the 'Game' class
        self._game = Game(self.width, self.height, self.chance)
        self.tiles = self._game.get_board()

        # Default theme
        self.theme = themes['Classic']

        # Create the figure and axes
        self.fig, self.ax = plt.subplots(figsize=((self.width + 2) / 3., (self.height + 2) / 3))
        self.ax.set_aspect('equal')
        self.ax.set_frame_on(False)
        self.ax.set_xlim(-0.05, self.width + 0.05)
        self.ax.set_ylim(-0.05, self.height + 0.05)

        # Create bomb count text element
        self.bomb_count_text = self.ax.text(self.width / 4, self.height + 0.3,
                                            f"Flags left: {np.sum(self.tiles == 9)}",
                                            color='red', ha='center', va='center')

        # Create timer text element
        self.start_time = 0
        self.timer_text = self.ax.text(3 * self.width / 4, self.height + 0.3, "Time: 0",
                                       color='blue', ha='center', va='center', visible=True)

        # Create score text element
        self.score_text = self.ax.text(3 * self.width / 4, self.height + 0.6, "Score: 0",
                                       color='green', ha='center', va='center', visible=True)

        # Create reset button
        reset_button_ax = plt.axes([0.45, 0.95, 0.1, 0.05])
        self.reset_button = Button(reset_button_ax, 'Reset')
        self.reset_button.on_clicked(self._reset_board)

        # Create radio buttons for AI models
        radio_labels = ['off', 'Adam', 'RMS', 'SGD', 'Conv1D: Adam', 'Conv2D: Adam']
        self._ai_on = False
        radio_axes = plt.axes([0.05, 0.45, 0.1, 0.2], facecolor='lightgoldenrodyellow')
        self.radio_buttons = RadioButtons(radio_axes, radio_labels)
        self.radio_buttons.on_clicked(self._radio_button_selected)

        # Create the theme selection buttons
        theme_button_ax = plt.axes([0.85, 0.95, 0.1, 0.05], facecolor='lightgoldenrodyellow')
        self.theme_buttons = RadioButtons(theme_button_ax, list(themes.keys()))
        self.theme_buttons.on_clicked(self._change_theme)

        # Create the grid of squares
        self.squares = np.array([[RegularPolygon((i + 0.5, j + 0.5),
                                                 numVertices=4,
                                                 radius=0.5 * np.sqrt(2),
                                                 orientation=np.pi / 4,
                                                 ec=self.edge_color,
                                                 fc=self.covered_color)
                                  for j in range(self.height)]
                                 for i in range(self.width)])
        [self.ax.add_patch(sq) for sq in self.squares.flat]

        # Internal state variables
        self.clicked = np.zeros((self.width, self.height), dtype=bool)
        self.flags = np.zeros((self.width, self.height), dtype=object)
        self.game_over = False

        # Connect button press event to the _button_press method
        self.fig.canvas.mpl_connect('button_press_event', self._button_press)

        self._model = None
        # self._model = models.load_model("output/minesweeper_AI_Conv1D_binary.h5")

        # Create an automatic move button
        auto_move_button_ax = plt.axes([0.25, 0.95, 0.1, 0.05])
        self.auto_move_button = Button(auto_move_button_ax, 'Auto Move')
        self.auto_move_button.on_clicked(self._auto_move)


        # Add a hint button
        hint_button_ax = plt.axes([0.75, 0.95, 0.1, 0.05])
        self.hint_button = Button(hint_button_ax, 'Hint')
        self.hint_button.on_clicked(self._give_hint)


        self.best_move = None
        self.best_move_rating = None

        self.no_guess()

    def _set_difficulty_parameters(self):
        if self.difficulty == 'Beginner':
            self.width, self.height, self.chance = 9, 9, 0.125
        elif self.difficulty == 'Intermediate':
            self.width, self.height, self.chance = 16, 16, 0.15625
        elif self.difficulty == 'Expert':
            self.width, self.height, self.chance = 30, 16, 0.216

    def _change_theme(self, label):
        self.theme = themes[label]
        self._apply_theme()

    def _apply_theme(self):
        for i in range(self.width):
            for j in range(self.height):
                if not self.clicked[i, j]:
                    self.squares[i, j].set_facecolor(self.theme.covered_color)
                else:
                    self.squares[i, j].set_facecolor(self.theme.uncovered_color)
                self.squares[i, j].set_edgecolor(self.theme.edge_color)

        for text in self.ax.texts:
            if text._text.isdigit():
                num = int(text._text)
                text.set_color(self.theme.text_colors[num])

        self._update_flag_colors()
        self.fig.canvas.draw_idle()

    def _update_flag_colors(self):
        for (i, j) in zip(*np.where(self.flags.astype(bool))):
            patch_to_remove = self.flags[i, j]
            patch_to_remove.remove()
            new_flag = plt.Polygon(self.flag_vertices + [i, j], fc=self.theme.flag_color, ec='black', lw=2)
            self.ax.add_patch(new_flag)
            self.flags[i, j] = new_flag

    def _reset_board(self, event):
        # Method to reset the Minesweeper board

        # Check if the reset is already in progress
        self.first_click = True
        if self.resetting_board:
            return

        # Set the flag to indicate that the reset is in progress
        self.resetting_board = True

        # Add code to reset the game state, flags, and update the UI accordingly
        self.game_over = False
        self.clicked = np.zeros((self.width, self.height), dtype=bool)
        self.flags = np.zeros((self.width, self.height), dtype=object)
        self._game = Game(self.width, self.height, self.chance)
        self.tiles = self._game.get_board()

        self.animation = None  # Set animation to None to break out of the generator loop

        # Clear existing patches and texts
        for patch in self.ax.patches:
            patch.remove()
        for text in self.ax.texts:
            text.remove()

        # Recreate the grid of squares using the updated self.tiles
        self.squares = np.array([[RegularPolygon((i + 0.5, j + 0.5),
                                                 numVertices=4,
                                                 radius=0.5 * np.sqrt(2),
                                                 orientation=np.pi / 4,
                                                 ec=self.edge_color,
                                                 fc=self.covered_color)
                                  for j in range(self.height)]
                                 for i in range(self.width)])
        [self.ax.add_patch(sq) for sq in self.squares.flat]

        # Reset the bomb count and timer UI
        self.bomb_count_text = self.ax.text(self.width / 4, self.height + 0.3,
                                            f"Flags left: {np.sum(self.tiles == 9)}",
                                            color='red', ha='center', va='center')
        self.start_time = datetime.now()
        self.timer_text = self.ax.text(3 * self.width / 4, self.height + 0.3, "Time: 0",
                                       color='blue', ha='center', va='center', visible=True)

        self._update_bomb_count()
        self.timer_text.set_text("Time: 0")
        self.reset_button.label.set_text("Reset")

        # Reset the flag after the reset is complete
        self.resetting_board = False

        # Redraw the updated UI
        self.fig.canvas.draw_idle()

        self._apply_theme()

        self.no_guess()


    def _update_timer_text(self, frame):
        if self.animation is not None:
            elapsed_time = datetime.now() - self.start_time
            self.timer_text.set_text("Time: " + str(elapsed_time.seconds))
            self.fig.canvas.draw_idle()

    def _calculate_score(self):
        end_time = datetime.now()
        elapsed_time = (end_time - self.start_time).seconds
        moves_taken = np.sum(self.clicked)
        score = max(0, 10000 - (elapsed_time * 10 + moves_taken * 5))
        return score

    def _update_bomb_count(self):
        flagged_count = np.sum(self.flags.astype(bool))
        bombs_left = np.sum(self.tiles == 9) - flagged_count
        self.bomb_count_text.set_text(f"Flags left: {bombs_left}")
        self.fig.canvas.draw_idle()

    def _draw_mine(self, i, j):
        self.ax.add_patch(plt.Circle((i + 0.5, j + 0.5), radius=0.25,
                                     ec='black', fc='black'))

    def _draw_red_X(self, i, j, opacity=1):
        self.ax.text(i + 0.5, j + 0.5, 'X', color='red', fontsize=20,
                     ha='center', va='center', alpha=opacity)

    def _draw_green_X(self, i, j):
        self.ax.text(i + 0.5, j + 0.5, 'X', color='green', fontsize=20,
                     ha='center', va='center')

    def _draw_grey_X(self, i, j):
        self.ax.text(i + 0.5, j + 0.5, 'X', color='gray', fontsize=20,
                     ha='center', va='center')

    def _toggle_mine_flag(self, i, j):
        if self.clicked[i, j]:
            pass
        elif self.flags[i, j]:
            patch_to_remove = self.flags[i, j]
            patch_to_remove.remove()
            self.flags[i, j] = None
        else:
            new_flag = plt.Polygon(self.flag_vertices + [i, j], fc=self.theme.flag_color, ec='black', lw=2)
            self.ax.add_patch(new_flag)
            self.flags[i, j] = new_flag
        self._update_bomb_count()

    def _reveal_unmarked_mines(self):
        for patch in self.ax.patches:
            if isinstance(patch, plt.Circle):
                patch.remove()
        for (i, j) in zip(*np.where((self.tiles == 9) & ~self.flags.astype(bool))):
            self._draw_mine(i, j)

    def _cross_out_wrong_flags(self):
        for (i, j) in zip(*np.where((self.tiles != 9) & self.flags.astype(bool))):
            self._draw_red_X(i, j)

    def frame_generator(self):
        frame = 0
        while True:
            yield frame
            frame += 1

    def no_guess(self):
        i, j = self._game.get_start()
        self._draw_green_X(i, j)

    def _give_hint(self, event=None):
        safe_cells = np.argwhere((self.tiles != 9) & (~self.clicked))
        if safe_cells.size > 0:
            hint_cell = safe_cells[np.random.choice(safe_cells.shape[0])]
            self._draw_green_X(hint_cell[0], hint_cell[1])
            print(f"Hint: Safe cell at ({hint_cell[0]}, {hint_cell[1]})")

    def find_patterns(self, matrix, false_matrix, output_file):
        # with open(output_file, 'a', newline='') as csvfile:
        #     csv_writer = csv.writer(csvfile)
        #
        #     for i in range(2, matrix.shape[0] - 2):
        #         for j in range(2, matrix.shape[1] - 2):
        #             submatrix = matrix[i - 2:i + 3, j - 2:i + 3]
        #             false_submatrix = false_matrix[i - 2:i + 3, j - 2:j + 3]
        #             sub_submatrix = matrix[i - 1:i + 2, j - 1:j + 2]
        #
        #             #if submatrix[2, 2] == -2 and np.any((sub_submatrix != -1) & (sub_submatrix != 0) & (sub_submatrix != -2)):
        #             if submatrix[2, 2] == -1 and np.any((sub_submatrix != -1) & (sub_submatrix != 0)):
        #                 # Flatten the submatrix and concatenate with the result
        #                 flattened_submatrix = false_submatrix.flatten()
        #                 result = 1 if self.tiles[i - 2, j - 2] == 9 else 0
        #
        #                 # Write to CSV file
        #                 csv_writer.writerow([result] + list(flattened_submatrix))

        for text in self.ax.texts:
            if text._text == 'X':
                text.remove()

        if self._ai_on:
            for i in range(2, matrix.shape[0] - 2):
                for j in range(2, matrix.shape[1] - 2):
                    submatrix = matrix[i - 2:i + 3, j - 2:j + 3]
                    false_submatrix = false_matrix[i - 2:i + 3, j - 2:j + 3]
                    sub_submatrix = matrix[i - 1:i + 2, j - 1:j + 2]
                    # if submatrix[2, 2] == -2 and np.any((sub_submatrix != -1) & (sub_submatrix != 0) & (sub_submatrix != -2)):
                    if submatrix[2, 2] == -1 and np.any((sub_submatrix != -1) & (sub_submatrix != 0)):
                        # Flatten the submatrix and concatenate with the result
                        flattened_submatrix = false_submatrix.flatten()
                        flattened_submatrix = flattened_submatrix.reshape(1, 25, 1)

                        predictions = self._model.predict(flattened_submatrix)
                        # if predictions > 0.90:
                        #     self._draw_red_X(i - 2, j - 2)
                        #
                        # elif predictions < 0.1:
                        #     self._draw_green_X(i - 2, j - 2)
                        #
                        # else:
                        #     self._draw_grey_X(i-2,j-2)
                        if self.best_move == None and self.best_move_rating == None:
                            self.best_move = i - 2, j - 2
                            self.best_move_rating = 1 - predictions[0][0]
                        elif 1 - predictions[0][0] > self.best_move_rating:
                            self.best_move = i - 2, j - 2
                            # self.best_move_rating = 1 - predictions[0][0]
                        self._draw_red_X(i - 2, j - 2, predictions[0][0])

    def _radio_button_selected(self, label):
        print(f'Radio button selected: {label}')
        if label == "off":
            self._ai_on = False
            self._printState()
        else:
            self._ai_on = True
            if label == "Adam":
                self._model = models.load_model("output/minesweeper_AI_Dense_binary_Adam_Cheap.h5")
            elif label == "RMS":
                self._model = models.load_model("output/minesweeper_AI_Dense_binary_RMS_Cheap.h5")
            elif label == "SGD":
                self._model = models.load_model("output/minesweeper_AI_Dense_binary_SGD_Cheap.h5")
            elif label == "Conv1D: Adam":
                self._model = models.load_model("output/minesweeper_AI_Conv1D_binary_Adam.h5")
            elif label == "Conv2D: Adam":
                self._model = models.load_model("output/minesweeper_AI_Conv2D_binary_Adam.h5")
            self._printState()

    def _auto_move(self, event):
        if self._ai_on:
            if self.best_move:
                i, j = self.best_move
                if self.first_click:
                    i, j = self._game.get_start()
                self._click_square(i, j, True)
                self._printState()
        else:
            print("No AI Chosen")

    def _click_square(self, i, j, bot=False):
        if self.first_click:
            self._handle_first_click()
        if self.flags[i, j] or self.clicked[i, j]:
            return
        self.clicked[i, j] = True
        if self.tiles[i][j] == 9:
            self._handle_mine_click(i, j)
        else:
            self._reveal_square(i, j)
            if self._check_victory():
                self._handle_victory()
        self._update_bomb_count()
        self.fig.canvas.draw_idle()

    def _handle_first_click(self):
        self.first_click = False
        self.start_time = datetime.now()
        self.animation = FuncAnimation(self.fig, self._update_timer_text, interval=1000)

    def _handle_mine_click(self, i, j):
        self.game_over = True
        self._reveal_unmarked_mines()
        self._draw_red_X(i, j)
        self._cross_out_wrong_flags()
        self.animation = None

    def _reveal_square(self, i, j):
        self.squares[i, j].set_facecolor(self.theme.uncovered_color)
        if self.tiles[i][j] == 0:
            self._reveal_neighbors(i, j)
        else:
            num = self.tiles[i][j]
            self.ax.text(i + 0.5, j + 0.5, str(num), color=self.theme.text_colors[num],
                         ha='center', va='center', fontsize=18, fontweight='bold')

    def _reveal_neighbors(self, i, j):
        for ii in range(max(0, i - 1), min(self.width, i + 2)):
            for jj in range(max(0, j - 1), min(self.height, j + 2)):
                self._click_square(ii, jj)

    def _check_victory(self):
        non_bomb_tiles = np.where(self.tiles != 9)
        return np.all(self.clicked[non_bomb_tiles])

    def _handle_victory(self):
        self.game_over = True
        score = self._calculate_score()
        self.score_text.set_text(f"Score: {score}")
        self.reset_button.label.set_text("Victory Lap?")
        self.animation = None

    def _check_and_reveal_neighbors(self, i, j):
        flag_count = np.sum(self.flags[max(0, i - 1):i + 2, max(0, j - 1):j + 2].astype(bool))
        if self.tiles[i][j] == flag_count:
            self._reveal_neighbors(i, j)

    def _button_press(self, event):
        if self._invalid_button_press(event):
            return

        i, j = map(int, (event.xdata, event.ydata))
        if (i < 0 or j < 0 or i >= self.width or j >= self.height):
            return

        if event.button == 1:
            self._handle_left_click(i, j)
        elif event.button == 3:
            self._toggle_mine_flag(i, j)

        self.fig.canvas.draw()
        self._printState()

    def _invalid_button_press(self, event):
        return self.game_over or event.xdata is None or event.ydata is None or event.inaxes in [
            self.auto_move_button.ax, self.radio_buttons.ax, self.reset_button.ax, self.hint_button.ax, self.theme_buttons.ax]

    def _handle_left_click(self, i, j):
        if self.clicked[i, j]:
            self._check_and_reveal_neighbors(i, j)
        else:
            self._click_square(i, j)

    def _printState(self):
        ## -1 == flag
        ## -2 == unknown

        self._state = np.empty((len(self.tiles), len(self.tiles[0])), dtype=int)
        self._false_state = np.empty((len(self.tiles), len(self.tiles[0])), dtype=int)

        for i in range(len(self.tiles)):
            for j in range(len(self.tiles[i])):
                if self.clicked[i, j]:
                    self._state[i, j] = self.tiles[i, j]
                    self._false_state[i, j] = self.tiles[i, j]
                elif self.flags[i, j]:
                    self._state[i, j] = 0
                    self._false_state[i, j] = 0
                else:
                    self._state[i, j] = -1
                    self._false_state[i, j] = 0

        self._state = np.pad(self._state, pad_width=2, constant_values=0)
        self._false_state = np.pad(self._false_state, pad_width=2, constant_values=0)

        self.find_patterns(self._state, self._false_state, 'input/testing_newgen.csv')


def main():
    # Initialize and show the MineSweeper game
    # 'Beginner' , 'Intermediate', 'Expert'
    m = MineSweeper('Beginner')
    plt.show()

if __name__ == '__main__':
    main()
